import {
  detectFeatures,
  getDefaultConfig,
  parse,
  parseAspectRatio,
  parseRangeString,
  parseSlide,
  prettify,
  prettifySlide,
  resolveConfig,
  resolveFonts,
  stringify,
  stringifySlide,
  verifyConfig
} from "./chunk-RKDOPE3N.mjs";

// src/fs.ts
import { promises as fs } from "node:fs";
import { dirname, resolve } from "node:path";
import YAML from "yaml";
import { slash } from "@antfu/utils";
var preparserExtensionLoader = null;
function injectPreparserExtensionLoader(fn) {
  preparserExtensionLoader = fn;
}
async function load(userRoot, filepath, content, mode) {
  const markdown = content ?? await fs.readFile(filepath, "utf-8");
  let extensions;
  if (preparserExtensionLoader) {
    const lines = markdown.split(/\r?\n/g);
    let hm = "";
    if (lines[0].match(/^---([^-].*)?$/) && !lines[1]?.match(/^\s*$/)) {
      let hEnd = 1;
      while (hEnd < lines.length && !lines[hEnd].trimEnd().match(/^---$/))
        hEnd++;
      hm = lines.slice(1, hEnd).join("\n");
    }
    const o = YAML.parse(hm) ?? {};
    extensions = await preparserExtensionLoader(o, filepath, mode);
  }
  const markdownFiles = {};
  const slides = [];
  async function loadMarkdown(path, range, frontmatterOverride, importers) {
    let md = markdownFiles[path];
    if (!md) {
      const raw = await fs.readFile(path, "utf-8");
      md = await parse(raw, path, extensions);
      markdownFiles[path] = md;
    }
    const directImporter = importers?.at(-1);
    for (const index of parseRangeString(md.slides.length, range)) {
      const subSlide = md.slides[index - 1];
      await loadSlide(subSlide, frontmatterOverride, importers);
      if (directImporter)
        (directImporter.imports ??= []).push(subSlide);
    }
    return md;
  }
  async function loadSlide(slide, frontmatterOverride, importChain) {
    if (slide.frontmatter.disabled || slide.frontmatter.hide)
      return;
    if (slide.frontmatter.src) {
      const [rawPath, rangeRaw] = slide.frontmatter.src.split("#");
      const path = slash(
        rawPath.startsWith("/") ? resolve(userRoot, rawPath.substring(1)) : resolve(dirname(slide.filepath), rawPath)
      );
      frontmatterOverride = {
        ...slide.frontmatter,
        ...frontmatterOverride
      };
      delete frontmatterOverride.src;
      await loadMarkdown(path, rangeRaw, frontmatterOverride, importChain ? [...importChain, slide] : [slide]);
    } else {
      slides.push({
        index: slides.length,
        importChain,
        source: slide,
        frontmatter: { ...slide.frontmatter, ...frontmatterOverride },
        content: slide.content,
        note: slide.note,
        title: slide.title,
        level: slide.level
      });
    }
  }
  const entry = await loadMarkdown(slash(filepath));
  const headmatter = { ...entry.slides[0]?.frontmatter };
  if (slides[0]?.title)
    headmatter.title = slides[0].title;
  return {
    slides,
    entry,
    headmatter,
    features: detectFeatures(slides.map((s) => s.source.raw).join("")),
    markdownFiles,
    watchFiles: Object.keys(markdownFiles).map(slash)
  };
}
async function save(markdown) {
  const fileContent = stringify(markdown);
  await fs.writeFile(markdown.filepath, fileContent, "utf-8");
  return fileContent;
}
export {
  detectFeatures,
  getDefaultConfig,
  injectPreparserExtensionLoader,
  load,
  parse,
  parseAspectRatio,
  parseRangeString,
  parseSlide,
  prettify,
  prettifySlide,
  resolveConfig,
  resolveFonts,
  save,
  stringify,
  stringifySlide,
  verifyConfig
};
